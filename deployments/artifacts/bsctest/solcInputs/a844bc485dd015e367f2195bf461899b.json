{
  "language": "Solidity",
  "sources": {
    "contracts/BaseDocumentStore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n\r\ncontract BaseDocumentStore is Initializable {\r\n  string public name;\r\n  string public version;\r\n\r\n  /// A mapping of the document hash to the block number that was issued\r\n  mapping(bytes32 => uint256) public documentIssued;\r\n  /// A mapping of the hash of the claim being revoked to the revocation block number\r\n  mapping(bytes32 => uint256) public documentRevoked;\r\n\r\n  event DocumentIssued(bytes32 indexed document);\r\n  event DocumentRevoked(bytes32 indexed document);\r\n\r\n  function initialize(string memory _name) public initializer {\r\n    version = \"2.3.0\";\r\n    name = _name;\r\n  }\r\n\r\n  function _issue(bytes32 document) internal onlyNotIssued(document) {\r\n    documentIssued[document] = block.number;\r\n    emit DocumentIssued(document);\r\n  }\r\n\r\n  function _bulkIssue(bytes32[] memory documents) internal {\r\n    for (uint256 i = 0; i < documents.length; i++) {\r\n      _issue(documents[i]);\r\n    }\r\n  }\r\n\r\n  function getIssuedBlock(bytes32 document) public view onlyIssued(document) returns (uint256) {\r\n    return documentIssued[document];\r\n  }\r\n\r\n  function isIssued(bytes32 document) public view returns (bool) {\r\n    return (documentIssued[document] != 0);\r\n  }\r\n\r\n  function isIssuedBefore(bytes32 document, uint256 blockNumber) public view returns (bool) {\r\n    return documentIssued[document] != 0 && documentIssued[document] <= blockNumber;\r\n  }\r\n\r\n  function _revoke(bytes32 document) internal onlyNotRevoked(document) returns (bool) {\r\n    documentRevoked[document] = block.number;\r\n    emit DocumentRevoked(document);\r\n  }\r\n\r\n  function _bulkRevoke(bytes32[] memory documents) internal {\r\n    for (uint256 i = 0; i < documents.length; i++) {\r\n      _revoke(documents[i]);\r\n    }\r\n  }\r\n\r\n  function isRevoked(bytes32 document) public view returns (bool) {\r\n    return documentRevoked[document] != 0;\r\n  }\r\n\r\n  function isRevokedBefore(bytes32 document, uint256 blockNumber) public view returns (bool) {\r\n    return documentRevoked[document] <= blockNumber && documentRevoked[document] != 0;\r\n  }\r\n\r\n  modifier onlyIssued(bytes32 document) {\r\n    require(isIssued(document), \"Error: Only issued document hashes can be revoked\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotIssued(bytes32 document) {\r\n    require(!isIssued(document), \"Error: Only hashes that have not been issued can be issued\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotRevoked(bytes32 claim) {\r\n    require(!isRevoked(claim), \"Error: Hash has been revoked previously\");\r\n    _;\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/OwnableDocumentStore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./BaseDocumentStore.sol\";\r\n\r\ncontract OwnableDocumentStore is BaseDocumentStore, Ownable {\r\n  constructor(string memory _name) public {\r\n    BaseDocumentStore.initialize(_name);\r\n  }\r\n\r\n  function issue(bytes32 document) public onlyOwner onlyNotIssued(document) {\r\n    BaseDocumentStore._issue(document);\r\n  }\r\n\r\n  function bulkIssue(bytes32[] memory documents) public onlyOwner {\r\n    BaseDocumentStore._bulkIssue(documents);\r\n  }\r\n\r\n  function revoke(bytes32 document) public onlyOwner onlyNotRevoked(document) returns (bool) {\r\n    return BaseDocumentStore._revoke(document);\r\n  }\r\n\r\n  function bulkRevoke(bytes32[] memory documents) public onlyOwner {\r\n    return BaseDocumentStore._bulkRevoke(documents);\r\n  }\r\n}\r\n"
    },
    "contracts/DocumentStore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/*\r\n * Legacy version for reference and backward compatibility, similar to OwnableDocumentStore\r\n */\r\ncontract DocumentStore is Ownable {\r\n  string public name;\r\n  string public version = \"2.3.0\";\r\n\r\n  /// A mapping of the document hash to the block number that was issued\r\n  mapping(bytes32 => uint256) public documentIssued;\r\n  /// A mapping of the hash of the claim being revoked to the revocation block number\r\n  mapping(bytes32 => uint256) public documentRevoked;\r\n\r\n  event DocumentIssued(bytes32 indexed document, address indexed sender );\r\n  event DocumentRevoked(bytes32 indexed document, address indexed sender);\r\n\r\n  constructor(string memory _name) public {\r\n    name = _name;\r\n  }\r\n\r\n  function issue(bytes32 document) public onlyOwner onlyNotIssued(document) {\r\n    documentIssued[document] = block.number;\r\n    emit DocumentIssued(document, msg.sender);\r\n  }\r\n\r\n  function bulkIssue(bytes32[] memory documents) public {\r\n    for (uint256 i = 0; i < documents.length; i++) {\r\n      issue(documents[i]);\r\n    }\r\n  }\r\n\r\n  function getIssuedBlock(bytes32 document) public view onlyIssued(document) returns (uint256) {\r\n    return documentIssued[document];\r\n  }\r\n\r\n  function isIssued(bytes32 document) public view returns (bool) {\r\n    return (documentIssued[document] != 0);\r\n  }\r\n\r\n  function isIssuedBefore(bytes32 document, uint256 blockNumber) public view returns (bool) {\r\n    return documentIssued[document] != 0 && documentIssued[document] <= blockNumber;\r\n  }\r\n\r\n  function revoke(bytes32 document) public onlyOwner onlyNotRevoked(document) returns (bool) {\r\n    documentRevoked[document] = block.number;\r\n    emit DocumentRevoked(document, msg.sender);\r\n  }\r\n\r\n  function bulkRevoke(bytes32[] memory documents) public {\r\n    for (uint256 i = 0; i < documents.length; i++) {\r\n      revoke(documents[i]);\r\n    }\r\n  }\r\n\r\n  function isRevoked(bytes32 document) public view returns (bool) {\r\n    return documentRevoked[document] != 0;\r\n  }\r\n\r\n  function isRevokedBefore(bytes32 document, uint256 blockNumber) public view returns (bool) {\r\n    return documentRevoked[document] <= blockNumber && documentRevoked[document] != 0;\r\n  }\r\n\r\n  modifier onlyIssued(bytes32 document) {\r\n    require(isIssued(document), \"Error: Only issued document hashes can be revoked\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotIssued(bytes32 document) {\r\n    require(!isIssued(document), \"Error: Only hashes that have not been issued can be issued\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyNotRevoked(bytes32 claim) {\r\n    require(!isRevoked(claim), \"Error: Hash has been revoked previously\");\r\n    _;\r\n  }\r\n}\r\n"
    },
    "contracts/DocumentFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./DocumentStore.sol\";\r\n\r\n\r\ncontract DocumentStoreFactory {\r\n  event DocumentStoreDeployed(address indexed instance, address indexed creator);\r\n  mapping(address => address) private records;\r\n  address private _owner;\r\n\r\n  constructor() {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  function deploy(string memory name) public returns (address) {\r\n    // solhint-disable-next-line mark-callable-contracts\r\n    DocumentStore instance = new DocumentStore(name);\r\n    instance.transferOwnership(msg.sender);\r\n    records[msg.sender] = address(instance);\r\n    emit DocumentStoreDeployed(address(instance), msg.sender);\r\n    return address(instance);\r\n  }\r\n\r\n  function getDocumentStore(address owner) public view returns (address) {\r\n      return records[owner];\r\n  }\r\n}\r\n"
    },
    "contracts/UpgradableDocumentStore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"./BaseDocumentStore.sol\";\r\n\r\ncontract UpgradableDocumentStore is BaseDocumentStore, OwnableUpgradeable {\r\n  function initialize(string memory _name, address owner) public initializer {\r\n    super.__Ownable_init();\r\n    super.transferOwnership(owner);\r\n    BaseDocumentStore.initialize(_name);\r\n  }\r\n\r\n  function issue(bytes32 document) public onlyOwner onlyNotIssued(document) {\r\n    BaseDocumentStore._issue(document);\r\n  }\r\n\r\n  function bulkIssue(bytes32[] memory documents) public onlyOwner {\r\n    BaseDocumentStore._bulkIssue(documents);\r\n  }\r\n\r\n  function revoke(bytes32 document) public onlyOwner onlyNotRevoked(document) returns (bool) {\r\n    return BaseDocumentStore._revoke(document);\r\n  }\r\n\r\n  function bulkRevoke(bytes32[] memory documents) public onlyOwner {\r\n    return BaseDocumentStore._bulkRevoke(documents);\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/DocumentStoreWithRevokeReasons.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./UpgradableDocumentStore.sol\";\r\n\r\ncontract DocumentStoreWithRevokeReasons is UpgradableDocumentStore {\r\n  /// A mapping of the document hash to the block number that was issued\r\n  mapping(bytes32 => uint256) public revokeReason;\r\n\r\n  event DocumentRevokedWithReason(bytes32 indexed document, uint256 reason);\r\n\r\n  function revoke(bytes32 document, uint256 reason) public onlyOwner onlyNotRevoked(document) returns (bool) {\r\n    revoke(document);\r\n    revokeReason[document] = reason;\r\n    emit DocumentRevokedWithReason(document, reason);\r\n  }\r\n\r\n  function bulkRevoke(bytes32[] memory documents, uint256 reason) public {\r\n    for (uint256 i = 0; i < documents.length; i++) {\r\n      revoke(documents[i]);\r\n      revokeReason[documents[i]] = reason;\r\n      emit DocumentRevokedWithReason(documents[i], reason);\r\n    }\r\n  }\r\n}\r\n"
    },
    "contracts/DocumentStoreCreator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./UpgradableDocumentStore.sol\";\r\n\r\n// Naming this factory contract as DocumentStoreCreator so that typechain can name the factory of this\r\n// contract as DocumentStoreCreatorFactory and it does not collide with the automatically generated\r\n// DocumentStoreFactory automatically generated by typechain\r\ncontract DocumentStoreCreator {\r\n  event DocumentStoreDeployed(address indexed instance, address indexed creator);\r\n\r\n  function deploy(string memory name) public returns (address) {\r\n    // solhint-disable-next-line mark-callable-contracts\r\n    UpgradableDocumentStore instance = new UpgradableDocumentStore();\r\n    instance.initialize(name, msg.sender);\r\n    emit DocumentStoreDeployed(address(instance), msg.sender);\r\n    return address(instance);\r\n  }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}